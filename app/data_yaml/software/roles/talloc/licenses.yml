---
- path: talloc-2.1.5/talloc.h
  type: LGPL-3.0+
  text: "#ifndef _TALLOC_H_\n#define _TALLOC_H_\n/*\n   Unix SMB/CIFS implementation.\n
    \  Samba temporary memory allocation functions\n\n   Copyright (C) Andrew Tridgell
    2004-2005\n   Copyright (C) Stefan Metzmacher 2006\n\n     ** NOTE! The following
    LGPL license applies to the talloc\n     ** library. This does NOT imply that
    all of Samba is released\n     ** under the LGPL\n\n   This library is free software;
    you can redistribute it and/or\n   modify it under the terms of the GNU Lesser
    General Public\n   License as published by the Free Software Foundation; either\n
    \  version 3 of the License, or (at your option) any later version.\n\n   This
    library is distributed in the hope that it will be useful,\n   but WITHOUT ANY
    WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS
    FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more
    details.\n\n   You should have received a copy of the GNU Lesser General Public\n
    \  License along with this library; if not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include
    <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n\n#ifdef __cplusplus\nextern
    \"C\" {\n#endif\n\n/**\n * @defgroup talloc The talloc API\n *\n * talloc is a
    hierarchical, reference counted memory pool system with\n * destructors. It is
    the core memory allocator used in Samba.\n *\n * @{\n */\n\n#define TALLOC_VERSION_MAJOR
    2\n#define TALLOC_VERSION_MINOR 0\n\nint talloc_version_major(void);\nint talloc_version_minor(void);\n/*
    This is mostly useful only for testing */\nint talloc_test_get_magic(void);\n\n/**\n
    * @brief Define a talloc parent type\n *\n * As talloc is a hierarchial memory
    allocator, every talloc chunk is a\n * potential parent to other talloc chunks.
    So defining a separate type for a\n * talloc chunk is not strictly necessary.
    TALLOC_CTX is defined nevertheless,\n * as it provides an indicator for function
    arguments. You will frequently\n * write code like\n *\n * @code\n *      struct
    foo *foo_create(TALLOC_CTX *mem_ctx)\n *      {\n *              struct foo *result;\n
    *              result = talloc(mem_ctx, struct foo);\n *              if (result
    == NULL) return NULL;\n *                      ... initialize foo ...\n *              return
    result;\n *      }\n * @endcode\n *\n * In this type of allocating functions it
    is handy to have a general\n * TALLOC_CTX type to indicate which parent to put
    allocated structures on.\n */\ntypedef void TALLOC_CTX;\n\n/*\n  this uses a little
    trick to allow __LINE__ to be stringified\n*/\n#ifndef __location__\n#define __TALLOC_STRING_LINE1__(s)
    \   #s\n#define __TALLOC_STRING_LINE2__(s)   __TALLOC_STRING_LINE1__(s)\n#define
    __TALLOC_STRING_LINE3__  __TALLOC_STRING_LINE2__(__LINE__)\n#define __location__
    __FILE__ \":\" __TALLOC_STRING_LINE3__\n#endif\n\n#ifndef TALLOC_DEPRECATED\n#define
    TALLOC_DEPRECATED 0\n#endif\n\n#ifndef PRINTF_ATTRIBUTE\n#if (__GNUC__ >= 3)\n/**
    Use gcc attribute to check printf fns.  a1 is the 1-based index of\n * the parameter
    containing the format, and a2 the index of the first\n * argument. Note that some
    gcc 2.x versions don't handle this\n * properly **/\n#define PRINTF_ATTRIBUTE(a1,
    a2) __attribute__ ((format (__printf__, a1, a2)))\n#else\n#define PRINTF_ATTRIBUTE(a1,
    a2)\n#endif\n#endif\n\n#ifdef DOXYGEN\n/**\n * @brief Create a new talloc context.\n
    *\n * The talloc() macro is the core of the talloc library. It takes a memory\n
    * context and a type, and returns a pointer to a new area of memory of the\n *
    given type.\n *\n * The returned pointer is itself a talloc context, so you can
    use it as the\n * context argument to more calls to talloc if you wish.\n *\n
    * The returned pointer is a \"child\" of the supplied context. This means that
    if\n * you talloc_free() the context then the new child disappears as well.\n
    * Alternatively you can free just the child.\n *\n * @param[in]  ctx      A talloc
    context to create a new reference on or NULL to\n *                      create
    a new top level context.\n *\n * @param[in]  type     The type of memory to allocate.\n
    *\n * @return              A type casted talloc context or NULL on error.\n *\n
    * @code\n *      unsigned int *a, *b;\n *\n *      a = talloc(NULL, unsigned int);\n
    *      b = talloc(a, unsigned int);\n * @endcode\n *\n * @see talloc_zero\n *
    @see talloc_array\n * @see talloc_steal\n * @see talloc_free\n */\nvoid *talloc(const
    void *ctx, #type);\n#else\n#define talloc(ctx, type) (type *)talloc_named_const(ctx,
    sizeof(type), #type)\nvoid *_talloc(const void *context, size_t size);\n#endif\n\n/**\n
    * @brief Create a new top level talloc context.\n *\n * This function creates
    a zero length named talloc context as a top level\n * context. It is equivalent
    to:\n *\n * @code\n *      talloc_named(NULL, 0, fmt, ...);\n * @endcode\n * @param[in]
    \ fmt      Format string for the name.\n *\n * @param[in]  ...      Additional
    printf-style arguments.\n *\n * @return              The allocated memory chunk,
    NULL on error.\n *\n * @see talloc_named()\n */\nvoid *talloc_init(const char
    *fmt, ...) PRINTF_ATTRIBUTE(1,2);\n\n#ifdef DOXYGEN\n/**\n * @brief Free a chunk
    of talloc memory.\n *\n * The talloc_free() function frees a piece of talloc memory,
    and all its\n * children. You can call talloc_free() on any pointer returned by\n
    * talloc().\n *\n * The return value of talloc_free() indicates success or failure,
    with 0\n * returned for success and -1 for failure. A possible failure condition\n
    * is if the pointer had a destructor attached to it and the destructor\n * returned
    -1. See talloc_set_destructor() for details on\n * destructors. Likewise, if \"ptr\"
    is NULL, then the function will make\n * no modifications and return -1.\n *\n
    * From version 2.0 and onwards, as a special case, talloc_free() is\n * refused
    on pointers that have more than one parent associated, as talloc\n * would have
    no way of knowing which parent should be removed. This is\n * different from older
    versions in the sense that always the reference to\n * the most recently established
    parent has been destroyed. Hence to free a\n * pointer that has more than one
    parent please use talloc_unlink().\n *\n * To help you find problems in your code
    caused by this behaviour, if\n * you do try and free a pointer with more than
    one parent then the\n * talloc logging function will be called to give output
    like this:\n *\n * @code\n *   ERROR: talloc_free with references at some_dir/source/foo.c:123\n
    *     reference at some_dir/source/other.c:325\n *     reference at some_dir/source/third.c:121\n
    * @endcode\n *\n * Please see the documentation for talloc_set_log_fn() and\n
    * talloc_set_log_stderr() for more information on talloc logging\n * functions.\n
    *\n * If <code>TALLOC_FREE_FILL</code> environment variable is set,\n * the memory
    occupied by the context is filled with the value of this variable.\n * The value
    should be a numeric representation of the character you want to\n * use.\n *\n
    * talloc_free() operates recursively on its children.\n *\n * @param[in]  ptr
    \     The chunk to be freed.\n *\n * @return              Returns 0 on success
    and -1 on error. A possible\n *                      failure condition is if the
    pointer had a destructor\n *                      attached to it and the destructor
    returned -1. Likewise,\n *                      if \"ptr\" is NULL, then the function
    will make no\n *                      modifications and returns -1.\n *\n * Example:\n
    * @code\n *      unsigned int *a, *b;\n *      a = talloc(NULL, unsigned int);\n
    *      b = talloc(a, unsigned int);\n *\n *      talloc_free(a); // Frees a and
    b\n * @endcode\n *\n * @see talloc_set_destructor()\n * @see talloc_unlink()\n
    */\nint talloc_free(void *ptr);\n#else\n#define talloc_free(ctx) _talloc_free(ctx,
    __location__)\nint _talloc_free(void *ptr, const char *location);\n#endif\n\n/**\n
    * @brief Free a talloc chunk's children.\n *\n * The function walks along the
    list of all children of a talloc context and\n * talloc_free()s only the children,
    not the context itself.\n *\n * A NULL argument is handled as no-op.\n *\n * @param[in]
    \ ptr      The chunk that you want to free the children of\n *                      (NULL
    is allowed too)\n */\nvoid talloc_free_children(void *ptr);\n\n#ifdef DOXYGEN\n/**\n
    * @brief Assign a destructor function to be called when a chunk is freed.\n *\n
    * The function talloc_set_destructor() sets the \"destructor\" for the pointer\n
    * \"ptr\". A destructor is a function that is called when the memory used by a\n
    * pointer is about to be released. The destructor receives the pointer as an\n
    * argument, and should return 0 for success and -1 for failure.\n *\n * The destructor
    can do anything it wants to, including freeing other pieces\n * of memory. A common
    use for destructors is to clean up operating system\n * resources (such as open
    file descriptors) contained in the structure the\n * destructor is placed on.\n
    *\n * You can only place one destructor on a pointer. If you need more than one\n
    * destructor then you can create a zero-length child of the pointer and place\n
    * an additional destructor on that.\n *\n * To remove a destructor call talloc_set_destructor()
    with NULL for the\n * destructor.\n *\n * If your destructor attempts to talloc_free()
    the pointer that it is the\n * destructor for then talloc_free() will return -1
    and the free will be\n * ignored. This would be a pointless operation anyway,
    as the destructor is\n * only called when the memory is just about to go away.\n
    *\n * @param[in]  ptr      The talloc chunk to add a destructor to.\n *\n * @param[in]
    \ destructor  The destructor function to be called. NULL to remove\n *                         it.\n
    *\n * Example:\n * @code\n *      static int destroy_fd(int *fd) {\n *              close(*fd);\n
    *              return 0;\n *      }\n *\n *      int *open_file(const char *filename)
    {\n *              int *fd = talloc(NULL, int);\n *              *fd = open(filename,
    O_RDONLY);\n *              if (*fd < 0) {\n *                      talloc_free(fd);\n
    *                      return NULL;\n *              }\n *              // Whenever
    they free this, we close the file.\n *              talloc_set_destructor(fd,
    destroy_fd);\n *              return fd;\n *      }\n * @endcode\n *\n * @see
    talloc()\n * @see talloc_free()\n */\nvoid talloc_set_destructor(const void *ptr,
    int (*destructor)(void *));\n\n/**\n * @brief Change a talloc chunk's parent.\n
    *\n * The talloc_steal() function changes the parent context of a talloc\n * pointer.
    It is typically used when the context that the pointer is\n * currently a child
    of is going to be freed and you wish to keep the\n * memory for a longer time.\n
    *\n * To make the changed hierarchy less error-prone, you might consider to use\n
    * talloc_move().\n *\n * If you try and call talloc_steal() on a pointer that
    has more than one\n * parent then the result is ambiguous. Talloc will choose
    to remove the\n * parent that is currently indicated by talloc_parent() and replace
    it with\n * the chosen parent. You will also get a message like this via the talloc\n
    * logging functions:\n *\n * @code\n *   WARNING: talloc_steal with references
    at some_dir/source/foo.c:123\n *     reference at some_dir/source/other.c:325\n
    *     reference at some_dir/source/third.c:121\n * @endcode\n *\n * To unambiguously
    change the parent of a pointer please see the function\n * talloc_reparent().
    See the talloc_set_log_fn() documentation for more\n * information on talloc logging.\n
    *\n * @param[in]  new_ctx  The new parent context.\n *\n * @param[in]  ptr      The
    talloc chunk to move.\n *\n * @return              Returns the pointer that you
    pass it. It does not have\n *                      any failure modes.\n *\n *
    @note It is possible to produce loops in the parent/child relationship\n * if
    you are not careful with talloc_steal(). No guarantees are provided\n * as to
    your sanity or the safety of your data if you do this.\n */\nvoid *talloc_steal(const
    void *new_ctx, const void *ptr);\n#else /* DOXYGEN */\n/* try to make talloc_set_destructor()
    and talloc_steal() type safe,\n   if we have a recent gcc */\n#if (__GNUC__ >=
    3)\n#define _TALLOC_TYPEOF(ptr) __typeof__(ptr)\n#define talloc_set_destructor(ptr,
    function)\t\t\t\t      \\\n\tdo {\t\t\t\t\t\t\t\t      \\\n\t\tint (*_talloc_destructor_fn)(_TALLOC_TYPEOF(ptr))
    = (function);\t      \\\n\t\t_talloc_set_destructor((ptr), (int (*)(void *))_talloc_destructor_fn);
    \\\n\t} while(0)\n/* this extremely strange macro is to avoid some braindamaged
    warning\n   stupidity in gcc 4.1.x */\n#define talloc_steal(ctx, ptr) ({ _TALLOC_TYPEOF(ptr)
    __talloc_steal_ret = (_TALLOC_TYPEOF(ptr))_talloc_steal_loc((ctx),(ptr), __location__);
    __talloc_steal_ret; })\n#else /* __GNUC__ >= 3 */\n#define talloc_set_destructor(ptr,
    function) \\\n\t_talloc_set_destructor((ptr), (int (*)(void *))(function))\n#define
    _TALLOC_TYPEOF(ptr) void *\n#define talloc_steal(ctx, ptr) (_TALLOC_TYPEOF(ptr))_talloc_steal_loc((ctx),(ptr),
    __location__)\n#endif /* __GNUC__ >= 3 */\nvoid _talloc_set_destructor(const void
    *ptr, int (*_destructor)(void *));\nvoid *_talloc_steal_loc(const void *new_ctx,
    const void *ptr, const char *location);\n#endif /* DOXYGEN */\n\n/**\n * @brief
    Assign a name to a talloc chunk.\n *\n * Each talloc pointer has a \"name\". The
    name is used principally for\n * debugging purposes, although it is also possible
    to set and get the name on\n * a pointer in as a way of \"marking\" pointers in
    your code.\n *\n * The main use for names on pointer is for \"talloc reports\".
    See\n * talloc_report() and talloc_report_full() for details. Also see\n * talloc_enable_leak_report()
    and talloc_enable_leak_report_full().\n *\n * The talloc_set_name() function allocates
    memory as a child of the\n * pointer. It is logically equivalent to:\n *\n * @code\n
    *      talloc_set_name_const(ptr, talloc_asprintf(ptr, fmt, ...));\n * @endcode\n
    *\n * @param[in]  ptr      The talloc chunk to assign a name to.\n *\n * @param[in]
    \ fmt      Format string for the name.\n *\n * @param[in]  ...      Add printf-style
    additional arguments.\n *\n * @return              The assigned name, NULL on
    error.\n *\n * @note Multiple calls to talloc_set_name() will allocate more memory
    without\n * releasing the name. All of the memory is released when the ptr is
    freed\n * using talloc_free().\n */\nconst char *talloc_set_name(const void *ptr,
    const char *fmt, ...) PRINTF_ATTRIBUTE(2,3);\n\n#ifdef DOXYGEN\n/**\n * @brief
    Change a talloc chunk's parent.\n *\n * This function has the same effect as talloc_steal(),
    and additionally sets\n * the source pointer to NULL. You would use it like this:\n
    *\n * @code\n *      struct foo *X = talloc(tmp_ctx, struct foo);\n *      struct
    foo *Y;\n *      Y = talloc_move(new_ctx, &X);\n * @endcode\n *\n * @param[in]
    \ new_ctx  The new parent context.\n *\n * @param[in]  pptr     Pointer to the
    talloc chunk to move.\n *\n * @return              The pointer of the talloc chunk
    it has been moved to,\n *                      NULL on error.\n */\nvoid *talloc_move(const
    void *new_ctx, void **pptr);\n#else\n#define talloc_move(ctx, pptr) (_TALLOC_TYPEOF(*(pptr)))_talloc_move((ctx),(void
    *)(pptr))\nvoid *_talloc_move(const void *new_ctx, const void *pptr);\n#endif\n\n/**\n
    * @brief Assign a name to a talloc chunk.\n *\n * The function is just like talloc_set_name(),
    but it takes a string constant,\n * and is much faster. It is extensively used
    by the \"auto naming\" macros, such\n * as talloc_p().\n *\n * This function does
    not allocate any memory. It just copies the supplied\n * pointer into the internal
    representation of the talloc ptr. This means you\n * must not pass a name pointer
    to memory that will disappear before the ptr\n * is freed with talloc_free().\n
    *\n * @param[in]  ptr      The talloc chunk to assign a name to.\n *\n * @param[in]
    \ name     Format string for the name.\n */\nvoid talloc_set_name_const(const
    void *ptr, const char *name);\n\n/**\n * @brief Create a named talloc chunk.\n
    *\n * The talloc_named() function creates a named talloc pointer. It is\n * equivalent
    to:\n *\n * @code\n *      ptr = talloc_size(context, size);\n *      talloc_set_name(ptr,
    fmt, ....);\n * @endcode\n *\n * @param[in]  context  The talloc context to hang
    the result off.\n *\n * @param[in]  size     Number of char's that you want to
    allocate.\n *\n * @param[in]  fmt      Format string for the name.\n *\n * @param[in]
    \ ...      Additional printf-style arguments.\n *\n * @return              The
    allocated memory chunk, NULL on error.\n *\n * @see talloc_set_name()\n */\nvoid
    *talloc_named(const void *context, size_t size,\n\t\t   const char *fmt, ...)
    PRINTF_ATTRIBUTE(3,4);\n\n/**\n * @brief Basic routine to allocate a chunk of
    memory.\n *\n * This is equivalent to:\n *\n * @code\n *      ptr = talloc_size(context,
    size);\n *      talloc_set_name_const(ptr, name);\n * @endcode\n *\n * @param[in]
    \ context  The parent context.\n *\n * @param[in]  size     The number of char's
    that we want to allocate.\n *\n * @param[in]  name     The name the talloc block
    has.\n *\n * @return             The allocated memory chunk, NULL on error.\n
    */\nvoid *talloc_named_const(const void *context, size_t size, const char *name);\n\n#ifdef
    DOXYGEN\n/**\n * @brief Untyped allocation.\n *\n * The function should be used
    when you don't have a convenient type to pass to\n * talloc(). Unlike talloc(),
    it is not type safe (as it returns a void *), so\n * you are on your own for type
    checking.\n *\n * Best to use talloc() or talloc_array() instead.\n *\n * @param[in]
    \ ctx     The talloc context to hang the result off.\n *\n * @param[in]  size
    \   Number of char's that you want to allocate.\n *\n * @return             The
    allocated memory chunk, NULL on error.\n *\n * Example:\n * @code\n *      void
    *mem = talloc_size(NULL, 100);\n * @endcode\n */\nvoid *talloc_size(const void
    *ctx, size_t size);\n#else\n#define talloc_size(ctx, size) talloc_named_const(ctx,
    size, __location__)\n#endif\n\n#ifdef DOXYGEN\n/**\n * @brief Allocate into a
    typed pointer.\n *\n * The talloc_ptrtype() macro should be used when you have
    a pointer and want\n * to allocate memory to point at with this pointer. When
    compiling with\n * gcc >= 3 it is typesafe. Note this is a wrapper of talloc_size()
    and\n * talloc_get_name() will return the current location in the source file
    and\n * not the type.\n *\n * @param[in]  ctx      The talloc context to hang
    the result off.\n *\n * @param[in]  type     The pointer you want to assign the
    result to.\n *\n * @return              The properly casted allocated memory chunk,
    NULL on\n *                      error.\n *\n * Example:\n * @code\n *       unsigned
    int *a = talloc_ptrtype(NULL, a);\n * @endcode\n */\nvoid *talloc_ptrtype(const
    void *ctx, #type);\n#else\n#define talloc_ptrtype(ctx, ptr) (_TALLOC_TYPEOF(ptr))talloc_size(ctx,
    sizeof(*(ptr)))\n#endif\n\n#ifdef DOXYGEN\n/**\n * @brief Allocate a new 0-sized
    talloc chunk.\n *\n * This is a utility macro that creates a new memory context
    hanging off an\n * existing context, automatically naming it \"talloc_new: __location__\"
    where\n * __location__ is the source line it is called from. It is particularly\n
    * useful for creating a new temporary working context.\n *\n * @param[in]  ctx
    \     The talloc parent context.\n *\n * @return              A new talloc chunk,
    NULL on error.\n */\nvoid *talloc_new(const void *ctx);\n#else\n#define talloc_new(ctx)
    talloc_named_const(ctx, 0, \"talloc_new: \" __location__)\n#endif\n\n#ifdef DOXYGEN\n/**\n
    * @brief Allocate a 0-initizialized structure.\n *\n * The macro is equivalent
    to:\n *\n * @code\n *      ptr = talloc(ctx, type);\n *      if (ptr) memset(ptr,
    0, sizeof(type));\n * @endcode\n *\n * @param[in]  ctx      The talloc context
    to hang the result off.\n *\n * @param[in]  type     The type that we want to
    allocate.\n *\n * @return              Pointer to a piece of memory, properly
    cast to 'type *',\n *                      NULL on error.\n *\n * Example:\n *
    @code\n *      unsigned int *a, *b;\n *      a = talloc_zero(NULL, unsigned int);\n
    *      b = talloc_zero(a, unsigned int);\n * @endcode\n *\n * @see talloc()\n
    * @see talloc_zero_size()\n * @see talloc_zero_array()\n */\nvoid *talloc_zero(const
    void *ctx, #type);\n\n/**\n * @brief Allocate untyped, 0-initialized memory.\n
    *\n * @param[in]  ctx      The talloc context to hang the result off.\n *\n *
    @param[in]  size     Number of char's that you want to allocate.\n *\n * @return
    \             The allocated memory chunk.\n */\nvoid *talloc_zero_size(const void
    *ctx, size_t size);\n#else\n#define talloc_zero(ctx, type) (type *)_talloc_zero(ctx,
    sizeof(type), #type)\n#define talloc_zero_size(ctx, size) _talloc_zero(ctx, size,
    __location__)\nvoid *_talloc_zero(const void *ctx, size_t size, const char *name);\n#endif\n\n/**\n
    * @brief Return the name of a talloc chunk.\n *\n * @param[in]  ptr      The talloc
    chunk.\n *\n * @return              The current name for the given talloc pointer.\n
    *\n * @see talloc_set_name()\n */\nconst char *talloc_get_name(const void *ptr);\n\n/**\n
    * @brief Verify that a talloc chunk carries a specified name.\n *\n * This function
    checks if a pointer has the specified name. If it does\n * then the pointer is
    returned.\n *\n * @param[in]  ptr       The talloc chunk to check.\n *\n * @param[in]
    \ name      The name to check against.\n *\n * @return               The pointer
    if the name matches, NULL if it doesn't.\n */\nvoid *talloc_check_name(const void
    *ptr, const char *name);\n\n/**\n * @brief Get the parent chunk of a pointer.\n
    *\n * @param[in]  ptr      The talloc pointer to inspect.\n *\n * @return              The
    talloc parent of ptr, NULL on error.\n */\nvoid *talloc_parent(const void *ptr);\n\n/**\n
    * @brief Get a talloc chunk's parent name.\n *\n * @param[in]  ptr      The talloc
    pointer to inspect.\n *\n * @return              The name of ptr's parent chunk.\n
    */\nconst char *talloc_parent_name(const void *ptr);\n\n/**\n * @brief Get the
    total size of a talloc chunk including its children.\n *\n * The function returns
    the total size in bytes used by this pointer and all\n * child pointers. Mostly
    useful for debugging.\n *\n * Passing NULL is allowed, but it will only give a
    meaningful result if\n * talloc_enable_leak_report() or talloc_enable_leak_report_full()
    has\n * been called.\n *\n * @param[in]  ptr      The talloc chunk.\n *\n * @return
    \             The total size.\n */\nsize_t talloc_total_size(const void *ptr);\n\n/**\n
    * @brief Get the number of talloc chunks hanging off a chunk.\n *\n * The talloc_total_blocks()
    function returns the total memory block\n * count used by this pointer and all
    child pointers. Mostly useful for\n * debugging.\n *\n * Passing NULL is allowed,
    but it will only give a meaningful result if\n * talloc_enable_leak_report() or
    talloc_enable_leak_report_full() has\n * been called.\n *\n * @param[in]  ptr
    \     The talloc chunk.\n *\n * @return              The total size.\n */\nsize_t
    talloc_total_blocks(const void *ptr);\n\n#ifdef DOXYGEN\n/**\n * @brief Duplicate
    a memory area into a talloc chunk.\n *\n * The function is equivalent to:\n *\n
    * @code\n *      ptr = talloc_size(ctx, size);\n *      if (ptr) memcpy(ptr, p,
    size);\n * @endcode\n *\n * @param[in]  t        The talloc context to hang the
    result off.\n *\n * @param[in]  p        The memory chunk you want to duplicate.\n
    *\n * @param[in]  size     Number of char's that you want copy.\n *\n * @return
    \             The allocated memory chunk.\n *\n * @see talloc_size()\n */\nvoid
    *talloc_memdup(const void *t, const void *p, size_t size);\n#else\n#define talloc_memdup(t,
    p, size) _talloc_memdup(t, p, size, __location__)\nvoid *_talloc_memdup(const
    void *t, const void *p, size_t size, const char *name);\n#endif\n\n#ifdef DOXYGEN\n/**\n
    * @brief Assign a type to a talloc chunk.\n *\n * This macro allows you to force
    the name of a pointer to be of a particular\n * type. This can be used in conjunction
    with talloc_get_type() to do type\n * checking on void* pointers.\n *\n * It is
    equivalent to this:\n *\n * @code\n *      talloc_set_name_const(ptr, #type)\n
    * @endcode\n *\n * @param[in]  ptr      The talloc chunk to assign the type to.\n
    *\n * @param[in]  type     The type to assign.\n */\nvoid talloc_set_type(const
    char *ptr, #type);\n\n/**\n * @brief Get a typed pointer out of a talloc pointer.\n
    *\n * This macro allows you to do type checking on talloc pointers. It is\n *
    particularly useful for void* private pointers. It is equivalent to\n * this:\n
    *\n * @code\n *      (type *)talloc_check_name(ptr, #type)\n * @endcode\n *\n
    * @param[in]  ptr      The talloc pointer to check.\n *\n * @param[in]  type     The
    type to check against.\n *\n * @return              The properly casted pointer
    given by ptr, NULL on error.\n */\ntype *talloc_get_type(const void *ptr, #type);\n#else\n#define
    talloc_set_type(ptr, type) talloc_set_name_const(ptr, #type)\n#define talloc_get_type(ptr,
    type) (type *)talloc_check_name(ptr, #type)\n#endif\n\n#ifdef DOXYGEN\n/**\n *
    @brief Safely turn a void pointer into a typed pointer.\n *\n * This macro is
    used together with talloc(mem_ctx, struct foo). If you had to\n * assing the talloc
    chunk pointer to some void pointer variable,\n * talloc_get_type_abort() is the
    recommended way to get the convert the void\n * pointer back to a typed pointer.\n
    *\n * @param[in]  ptr      The void pointer to convert.\n *\n * @param[in]  type
    \    The type that this chunk contains\n *\n * @return              The same value
    as ptr, type-checked and properly cast.\n */\nvoid *talloc_get_type_abort(const
    void *ptr, #type);\n#else\n#ifdef TALLOC_GET_TYPE_ABORT_NOOP\n#define talloc_get_type_abort(ptr,
    type) (type *)(ptr)\n#else\n#define talloc_get_type_abort(ptr, type) (type *)_talloc_get_type_abort(ptr,
    #type, __location__)\n#endif\nvoid *_talloc_get_type_abort(const void *ptr, const
    char *name, const char *location);\n#endif\n\n/**\n * @brief Find a parent context
    by name.\n *\n * Find a parent memory context of the current context that has
    the given\n * name. This can be very useful in complex programs where it may be\n
    * difficult to pass all information down to the level you need, but you\n * know
    the structure you want is a parent of another context.\n *\n * @param[in]  ctx
    \     The talloc chunk to start from.\n *\n * @param[in]  name     The name of
    the parent we look for.\n *\n * @return              The memory context we are
    looking for, NULL if not\n *                      found.\n */\nvoid *talloc_find_parent_byname(const
    void *ctx, const char *name);\n\n#ifdef DOXYGEN\n/**\n * @brief Find a parent
    context by type.\n *\n * Find a parent memory context of the current context that
    has the given\n * name. This can be very useful in complex programs where it may
    be\n * difficult to pass all information down to the level you need, but you\n
    * know the structure you want is a parent of another context.\n *\n * Like talloc_find_parent_byname()
    but takes a type, making it typesafe.\n *\n * @param[in]  ptr      The talloc
    chunk to start from.\n *\n * @param[in]  type     The type of the parent to look
    for.\n *\n * @return              The memory context we are looking for, NULL
    if not\n *                      found.\n */\nvoid *talloc_find_parent_bytype(const
    void *ptr, #type);\n#else\n#define talloc_find_parent_bytype(ptr, type) (type
    *)talloc_find_parent_byname(ptr, #type)\n#endif\n\n/**\n * @brief Allocate a talloc
    pool.\n *\n * A talloc pool is a pure optimization for specific situations. In
    the\n * release process for Samba 3.2 we found out that we had become considerably\n
    * slower than Samba 3.0 was. Profiling showed that malloc(3) was a large CPU\n
    * consumer in benchmarks. For Samba 3.2 we have internally converted many\n *
    static buffers to dynamically allocated ones, so malloc(3) being beaten\n * more
    was no surprise. But it made us slower.\n *\n * talloc_pool() is an optimization
    to call malloc(3) a lot less for the use\n * pattern Samba has: The SMB protocol
    is mainly a request/response protocol\n * where we have to allocate a certain
    amount of memory per request and free\n * that after the SMB reply is sent to
    the client.\n *\n * talloc_pool() creates a talloc chunk that you can use as a
    talloc parent\n * exactly as you would use any other ::TALLOC_CTX. The difference
    is that\n * when you talloc a child of this pool, no malloc(3) is done. Instead,
    talloc\n * just increments a pointer inside the talloc_pool. This also works\n
    * recursively. If you use the child of the talloc pool as a parent for\n * grand-children,
    their memory is also taken from the talloc pool.\n *\n * If there is not enough
    memory in the pool to allocate the new child,\n * it will create a new talloc
    chunk as if the parent was a normal talloc\n * context.\n *\n * If you talloc_free()
    children of a talloc pool, the memory is not given\n * back to the system. Instead,
    free(3) is only called if the talloc_pool()\n * itself is released with talloc_free().\n
    *\n * The downside of a talloc pool is that if you talloc_move() a child of a\n
    * talloc pool to a talloc parent outside the pool, the whole pool memory is\n
    * not free(3)'ed until that moved chunk is also talloc_free()ed.\n *\n * @param[in]
    \ context  The talloc context to hang the result off.\n *\n * @param[in]  size
    \    Size of the talloc pool.\n *\n * @return              The allocated talloc
    pool, NULL on error.\n */\nvoid *talloc_pool(const void *context, size_t size);\n\n#ifdef
    DOXYGEN\n/**\n * @brief Allocate a talloc object as/with an additional pool.\n
    *\n * This is like talloc_pool(), but's it's more flexible\n * and allows an object
    to be a pool for its children.\n *\n * @param[in] ctx                   The talloc
    context to hang the result off.\n *\n * @param[in] type                  The type
    that we want to allocate.\n *\n * @param[in] num_subobjects        The expected
    number of subobjects, which will\n *                                  be allocated
    within the pool. This allocates\n *                                  space for
    talloc_chunk headers.\n *\n * @param[in] total_subobjects_size The size that all
    subobjects can use in total.\n *\n *\n * @return              The allocated talloc
    object, NULL on error.\n */\nvoid *talloc_pooled_object(const void *ctx, #type,\n\t\t\t
    \  unsigned num_subobjects,\n\t\t\t   size_t total_subobjects_size);\n#else\n#define
    talloc_pooled_object(_ctx, _type, \\\n\t\t\t     _num_subobjects, \\\n\t\t\t     _total_subobjects_size)
    \\\n\t(_type *)_talloc_pooled_object((_ctx), sizeof(_type), #_type, \\\n\t\t\t\t\t(_num_subobjects),
    \\\n\t\t\t\t\t(_total_subobjects_size))\nvoid *_talloc_pooled_object(const void
    *ctx,\n\t\t\t    size_t type_size,\n\t\t\t    const char *type_name,\n\t\t\t    unsigned
    num_subobjects,\n\t\t\t    size_t total_subobjects_size);\n#endif\n\n/**\n * @brief
    Free a talloc chunk and NULL out the pointer.\n *\n * TALLOC_FREE() frees a pointer
    and sets it to NULL. Use this if you want\n * immediate feedback (i.e. crash)
    if you use a pointer after having free'ed\n * it.\n *\n * @param[in]  ctx      The
    chunk to be freed.\n */\n#define TALLOC_FREE(ctx) do { if (ctx != NULL) { talloc_free(ctx);
    ctx=NULL; } } while(0)\n\n/* @} ******************************************************************/\n\n/**\n
    * \\defgroup talloc_ref The talloc reference function.\n * @ingroup talloc\n *\n
    * This module contains the definitions around talloc references\n *\n * @{\n */\n\n/**\n
    * @brief Increase the reference count of a talloc chunk.\n *\n * The talloc_increase_ref_count(ptr)
    function is exactly equivalent to:\n *\n * @code\n *      talloc_reference(NULL,
    ptr);\n * @endcode\n *\n * You can use either syntax, depending on which you think
    is clearer in\n * your code.\n *\n * @param[in]  ptr      The pointer to increase
    the reference count.\n *\n * @return              0 on success, -1 on error.\n
    */\nint talloc_increase_ref_count(const void *ptr);\n\n/**\n * @brief Get the
    number of references to a talloc chunk.\n *\n * @param[in]  ptr      The pointer
    to retrieve the reference count from.\n *\n * @return              The number
    of references.\n */\nsize_t talloc_reference_count(const void *ptr);\n\n#ifdef
    DOXYGEN\n/**\n * @brief Create an additional talloc parent to a pointer.\n *\n
    * The talloc_reference() function makes \"context\" an additional parent of\n
    * ptr. Each additional reference consumes around 48 bytes of memory on intel\n
    * x86 platforms.\n *\n * If ptr is NULL, then the function is a no-op, and simply
    returns NULL.\n *\n * After creating a reference you can free it in one of the
    following ways:\n *\n * - you can talloc_free() any parent of the original pointer.
    That\n *   will reduce the number of parents of this pointer by 1, and will\n
    *   cause this pointer to be freed if it runs out of parents.\n *\n * - you can
    talloc_free() the pointer itself if it has at maximum one\n *   parent. This behaviour
    has been changed since the release of version\n *   2.0. Further informations
    in the description of \"talloc_free\".\n *\n * For more control on which parent
    to remove, see talloc_unlink()\n * @param[in]  ctx      The additional parent.\n
    *\n * @param[in]  ptr      The pointer you want to create an additional parent
    for.\n *\n * @return              The original pointer 'ptr', NULL if talloc ran
    out of\n *                      memory in creating the reference.\n *\n * @warning
    You should try to avoid using this interface. It turns a beautiful\n *          talloc-tree
    into a graph. It is often really hard to debug if you\n *          screw something
    up by accident.\n *\n * Example:\n * @code\n *      unsigned int *a, *b, *c;\n
    *      a = talloc(NULL, unsigned int);\n *      b = talloc(NULL, unsigned int);\n
    *      c = talloc(a, unsigned int);\n *      // b also serves as a parent of c.\n
    *      talloc_reference(b, c);\n * @endcode\n *\n * @see talloc_unlink()\n */\nvoid
    *talloc_reference(const void *ctx, const void *ptr);\n#else\n#define talloc_reference(ctx,
    ptr) (_TALLOC_TYPEOF(ptr))_talloc_reference_loc((ctx),(ptr), __location__)\nvoid
    *_talloc_reference_loc(const void *context, const void *ptr, const char *location);\n#endif\n\n/**\n
    * @brief Remove a specific parent from a talloc chunk.\n *\n * The function removes
    a specific parent from ptr. The context passed must\n * either be a context used
    in talloc_reference() with this pointer, or must be\n * a direct parent of ptr.\n
    *\n * You can just use talloc_free() instead of talloc_unlink() if there\n * is
    at maximum one parent. This behaviour has been changed since the\n * release of
    version 2.0. Further informations in the description of\n * \"talloc_free\".\n
    *\n * @param[in]  context  The talloc parent to remove.\n *\n * @param[in]  ptr
    \     The talloc ptr you want to remove the parent from.\n *\n * @return              0
    on success, -1 on error.\n *\n * @note If the parent has already been removed
    using talloc_free() then\n * this function will fail and will return -1.  Likewise,
    if ptr is NULL,\n * then the function will make no modifications and return -1.\n
    *\n * @warning You should try to avoid using this interface. It turns a beautiful\n
    *          talloc-tree into a graph. It is often really hard to debug if you\n
    *          screw something up by accident.\n *\n * Example:\n * @code\n *      unsigned
    int *a, *b, *c;\n *      a = talloc(NULL, unsigned int);\n *      b = talloc(NULL,
    unsigned int);\n *      c = talloc(a, unsigned int);\n *      // b also serves
    as a parent of c.\n *      talloc_reference(b, c);\n *      talloc_unlink(b, c);\n
    * @endcode\n */\nint talloc_unlink(const void *context, void *ptr);\n\n/**\n *
    @brief Provide a talloc context that is freed at program exit.\n *\n * This is
    a handy utility function that returns a talloc context\n * which will be automatically
    freed on program exit. This can be used\n * to reduce the noise in memory leak
    reports.\n *\n * Never use this in code that might be used in objects loaded with\n
    * dlopen and unloaded with dlclose. talloc_autofree_context()\n * internally uses
    atexit(3). Some platforms like modern Linux handles\n * this fine, but for example
    FreeBSD does not deal well with dlopen()\n * and atexit() used simultaneously:
    dlclose() does not clean up the\n * list of atexit-handlers, so when the program
    exits the code that\n * was registered from within talloc_autofree_context() is
    gone, the\n * program crashes at exit.\n *\n * @return              A talloc context,
    NULL on error.\n */\nvoid *talloc_autofree_context(void);\n\n/**\n * @brief Get
    the size of a talloc chunk.\n *\n * This function lets you know the amount of
    memory allocated so far by\n * this context. It does NOT account for subcontext
    memory.\n * This can be used to calculate the size of an array.\n *\n * @param[in]
    \ ctx      The talloc chunk.\n *\n * @return              The size of the talloc
    chunk.\n */\nsize_t talloc_get_size(const void *ctx);\n\n/**\n * @brief Show the
    parentage of a context.\n *\n * @param[in]  context            The talloc context
    to look at.\n *\n * @param[in]  file               The output to use, a file,
    stdout or stderr.\n */\nvoid talloc_show_parents(const void *context, FILE *file);\n\n/**\n
    * @brief Check if a context is parent of a talloc chunk.\n *\n * This checks if
    context is referenced in the talloc hierarchy above ptr.\n *\n * @param[in]  context
    \ The assumed talloc context.\n *\n * @param[in]  ptr      The talloc chunk to
    check.\n *\n * @return              Return 1 if this is the case, 0 if not.\n
    */\nint talloc_is_parent(const void *context, const void *ptr);\n\n/**\n * @brief
    Change the parent context of a talloc pointer.\n *\n * The function changes the
    parent context of a talloc pointer. It is typically\n * used when the context
    that the pointer is currently a child of is going to be\n * freed and you wish
    to keep the memory for a longer time.\n *\n * The difference between talloc_reparent()
    and talloc_steal() is that\n * talloc_reparent() can specify which parent you
    wish to change. This is\n * useful when a pointer has multiple parents via references.\n
    *\n * @param[in]  old_parent\n * @param[in]  new_parent\n * @param[in]  ptr\n
    *\n * @return              Return the pointer you passed. It does not have any\n
    *                      failure modes.\n */\nvoid *talloc_reparent(const void *old_parent,
    const void *new_parent, const void *ptr);\n\n/* @} ******************************************************************/\n\n/**\n
    * @defgroup talloc_array The talloc array functions\n * @ingroup talloc\n *\n
    * Talloc contains some handy helpers for handling Arrays conveniently\n *\n *
    @{\n */\n\n#ifdef DOXYGEN\n/**\n * @brief Allocate an array.\n *\n * The macro
    is equivalent to:\n *\n * @code\n *      (type *)talloc_size(ctx, sizeof(type)
    * count);\n * @endcode\n *\n * except that it provides integer overflow protection
    for the multiply,\n * returning NULL if the multiply overflows.\n *\n * @param[in]
    \ ctx      The talloc context to hang the result off.\n *\n * @param[in]  type
    \    The type that we want to allocate.\n *\n * @param[in]  count    The number
    of 'type' elements you want to allocate.\n *\n * @return              The allocated
    result, properly cast to 'type *', NULL on\n *                      error.\n *\n
    * Example:\n * @code\n *      unsigned int *a, *b;\n *      a = talloc_zero(NULL,
    unsigned int);\n *      b = talloc_array(a, unsigned int, 100);\n * @endcode\n
    *\n * @see talloc()\n * @see talloc_zero_array()\n */\nvoid *talloc_array(const
    void *ctx, #type, unsigned count);\n#else\n#define talloc_array(ctx, type, count)
    (type *)_talloc_array(ctx, sizeof(type), count, #type)\nvoid *_talloc_array(const
    void *ctx, size_t el_size, unsigned count, const char *name);\n#endif\n\n#ifdef
    DOXYGEN\n/**\n * @brief Allocate an array.\n *\n * @param[in]  ctx      The talloc
    context to hang the result off.\n *\n * @param[in]  size     The size of an array
    element.\n *\n * @param[in]  count    The number of elements you want to allocate.\n
    *\n * @return              The allocated result, NULL on error.\n */\nvoid *talloc_array_size(const
    void *ctx, size_t size, unsigned count);\n#else\n#define talloc_array_size(ctx,
    size, count) _talloc_array(ctx, size, count, __location__)\n#endif\n\n#ifdef DOXYGEN\n/**\n
    * @brief Allocate an array into a typed pointer.\n *\n * The macro should be used
    when you have a pointer to an array and want to\n * allocate memory of an array
    to point at with this pointer. When compiling\n * with gcc >= 3 it is typesafe.
    Note this is a wrapper of talloc_array_size()\n * and talloc_get_name() will return
    the current location in the source file\n * and not the type.\n *\n * @param[in]
    \ ctx      The talloc context to hang the result off.\n *\n * @param[in]  ptr
    \     The pointer you want to assign the result to.\n *\n * @param[in]  count
    \   The number of elements you want to allocate.\n *\n * @return              The
    allocated memory chunk, properly casted. NULL on\n *                      error.\n
    */\nvoid *talloc_array_ptrtype(const void *ctx, const void *ptr, unsigned count);\n#else\n#define
    talloc_array_ptrtype(ctx, ptr, count) (_TALLOC_TYPEOF(ptr))talloc_array_size(ctx,
    sizeof(*(ptr)), count)\n#endif\n\n#ifdef DOXYGEN\n/**\n * @brief Get the number
    of elements in a talloc'ed array.\n *\n * A talloc chunk carries its own size,
    so for talloc'ed arrays it is not\n * necessary to store the number of elements
    explicitly.\n *\n * @param[in]  ctx      The allocated array.\n *\n * @return
    \             The number of elements in ctx.\n */\nsize_t talloc_array_length(const
    void *ctx);\n#else\n#define talloc_array_length(ctx) (talloc_get_size(ctx)/sizeof(*ctx))\n#endif\n\n#ifdef
    DOXYGEN\n/**\n * @brief Allocate a zero-initialized array\n *\n * @param[in]  ctx
    \     The talloc context to hang the result off.\n *\n * @param[in]  type     The
    type that we want to allocate.\n *\n * @param[in]  count    The number of \"type\"
    elements you want to allocate.\n *\n * @return              The allocated result
    casted to \"type *\", NULL on error.\n *\n * The talloc_zero_array() macro is
    equivalent to:\n *\n * @code\n *     ptr = talloc_array(ctx, type, count);\n *
    \    if (ptr) memset(ptr, sizeof(type) * count);\n * @endcode\n */\nvoid *talloc_zero_array(const
    void *ctx, #type, unsigned count);\n#else\n#define talloc_zero_array(ctx, type,
    count) (type *)_talloc_zero_array(ctx, sizeof(type), count, #type)\nvoid *_talloc_zero_array(const
    void *ctx,\n\t\t\t size_t el_size,\n\t\t\t unsigned count,\n\t\t\t const char
    *name);\n#endif\n\n#ifdef DOXYGEN\n/**\n * @brief Change the size of a talloc
    array.\n *\n * The macro changes the size of a talloc pointer. The 'count' argument
    is the\n * number of elements of type 'type' that you want the resulting pointer
    to\n * hold.\n *\n * talloc_realloc() has the following equivalences:\n *\n *
    @code\n *      talloc_realloc(ctx, NULL, type, 1) ==> talloc(ctx, type);\n *      talloc_realloc(ctx,
    NULL, type, N) ==> talloc_array(ctx, type, N);\n *      talloc_realloc(ctx, ptr,
    type, 0)  ==> talloc_free(ptr);\n * @endcode\n *\n * The \"context\" argument
    is only used if \"ptr\" is NULL, otherwise it is\n * ignored.\n *\n * @param[in]
    \ ctx      The parent context used if ptr is NULL.\n *\n * @param[in]  ptr      The
    chunk to be resized.\n *\n * @param[in]  type     The type of the array element
    inside ptr.\n *\n * @param[in]  count    The intended number of array elements.\n
    *\n * @return              The new array, NULL on error. The call will fail either\n
    *                      due to a lack of memory, or because the pointer has more\n
    *                      than one parent (see talloc_reference()).\n */\nvoid *talloc_realloc(const
    void *ctx, void *ptr, #type, size_t count);\n#else\n#define talloc_realloc(ctx,
    p, type, count) (type *)_talloc_realloc_array(ctx, p, sizeof(type), count, #type)\nvoid
    *_talloc_realloc_array(const void *ctx, void *ptr, size_t el_size, unsigned count,
    const char *name);\n#endif\n\n#ifdef DOXYGEN\n/**\n * @brief Untyped realloc to
    change the size of a talloc array.\n *\n * The macro is useful when the type is
    not known so the typesafe\n * talloc_realloc() cannot be used.\n *\n * @param[in]
    \ ctx      The parent context used if 'ptr' is NULL.\n *\n * @param[in]  ptr      The
    chunk to be resized.\n *\n * @param[in]  size     The new chunk size.\n *\n *
    @return              The new array, NULL on error.\n */\nvoid *talloc_realloc_size(const
    void *ctx, void *ptr, size_t size);\n#else\n#define talloc_realloc_size(ctx, ptr,
    size) _talloc_realloc(ctx, ptr, size, __location__)\nvoid *_talloc_realloc(const
    void *context, void *ptr, size_t size, const char *name);\n#endif\n\n/**\n * @brief
    Provide a function version of talloc_realloc_size.\n *\n * This is a non-macro
    version of talloc_realloc(), which is useful as\n * libraries sometimes want a
    ralloc function pointer. A realloc()\n * implementation encapsulates the functionality
    of malloc(), free() and\n * realloc() in one call, which is why it is useful to
    be able to pass around\n * a single function pointer.\n *\n * @param[in]  context
    \ The parent context used if ptr is NULL.\n *\n * @param[in]  ptr      The chunk
    to be resized.\n *\n * @param[in]  size     The new chunk size.\n *\n * @return
    \             The new chunk, NULL on error.\n */\nvoid *talloc_realloc_fn(const
    void *context, void *ptr, size_t size);\n\n/* @} ******************************************************************/\n\n/**\n
    * @defgroup talloc_string The talloc string functions.\n * @ingroup talloc\n *\n
    * talloc string allocation and manipulation functions.\n * @{\n */\n\n/**\n *
    @brief Duplicate a string into a talloc chunk.\n *\n * This function is equivalent
    to:\n *\n * @code\n *      ptr = talloc_size(ctx, strlen(p)+1);\n *      if (ptr)
    memcpy(ptr, p, strlen(p)+1);\n * @endcode\n *\n * This functions sets the name
    of the new pointer to the passed\n * string. This is equivalent to:\n *\n * @code\n
    *      talloc_set_name_const(ptr, ptr)\n * @endcode\n *\n * @param[in]  t        The
    talloc context to hang the result off.\n *\n * @param[in]  p        The string
    you want to duplicate.\n *\n * @return              The duplicated string, NULL
    on error.\n */\nchar *talloc_strdup(const void *t, const char *p);\n\n/**\n *
    @brief Append a string to given string.\n *\n * The destination string is reallocated
    to take\n * <code>strlen(s) + strlen(a) + 1</code> characters.\n *\n * This functions
    sets the name of the new pointer to the new\n * string. This is equivalent to:\n
    *\n * @code\n *      talloc_set_name_const(ptr, ptr)\n * @endcode\n *\n * If <code>s
    == NULL</code> then new context is created.\n *\n * @param[in]  s        The destination
    to append to.\n *\n * @param[in]  a        The string you want to append.\n *\n
    * @return              The concatenated strings, NULL on error.\n *\n * @see talloc_strdup()\n
    * @see talloc_strdup_append_buffer()\n */\nchar *talloc_strdup_append(char *s,
    const char *a);\n\n/**\n * @brief Append a string to a given buffer.\n *\n * This
    is a more efficient version of talloc_strdup_append(). It determines the\n * length
    of the destination string by the size of the talloc context.\n *\n * Use this
    very carefully as it produces a different result than\n * talloc_strdup_append()
    when a zero character is in the middle of the\n * destination string.\n *\n *
    @code\n *      char *str_a = talloc_strdup(NULL, \"hello world\");\n *      char
    *str_b = talloc_strdup(NULL, \"hello world\");\n *      str_a[5] = str_b[5] =
    '\\0'\n *\n *      char *app = talloc_strdup_append(str_a, \", hello\");\n *      char
    *buf = talloc_strdup_append_buffer(str_b, \", hello\");\n *\n *      printf(\"%s\\n\",
    app); // hello, hello (app = \"hello, hello\")\n *      printf(\"%s\\n\", buf);
    // hello (buf = \"hello\\0world, hello\")\n * @endcode\n *\n * If <code>s == NULL</code>
    then new context is created.\n *\n * @param[in]  s        The destination buffer
    to append to.\n *\n * @param[in]  a        The string you want to append.\n *\n
    * @return              The concatenated strings, NULL on error.\n *\n * @see talloc_strdup()\n
    * @see talloc_strdup_append()\n * @see talloc_array_length()\n */\nchar *talloc_strdup_append_buffer(char
    *s, const char *a);\n\n/**\n * @brief Duplicate a length-limited string into a
    talloc chunk.\n *\n * This function is the talloc equivalent of the C library
    function strndup(3).\n *\n * This functions sets the name of the new pointer to
    the passed string. This is\n * equivalent to:\n *\n * @code\n *      talloc_set_name_const(ptr,
    ptr)\n * @endcode\n *\n * @param[in]  t        The talloc context to hang the
    result off.\n *\n * @param[in]  p        The string you want to duplicate.\n *\n
    * @param[in]  n        The maximum string length to duplicate.\n *\n * @return
    \             The duplicated string, NULL on error.\n */\nchar *talloc_strndup(const
    void *t, const char *p, size_t n);\n\n/**\n * @brief Append at most n characters
    of a string to given string.\n *\n * The destination string is reallocated to
    take\n * <code>strlen(s) + strnlen(a, n) + 1</code> characters.\n *\n * This functions
    sets the name of the new pointer to the new\n * string. This is equivalent to:\n
    *\n * @code\n *      talloc_set_name_const(ptr, ptr)\n * @endcode\n *\n * If <code>s
    == NULL</code> then new context is created.\n *\n * @param[in]  s        The destination
    string to append to.\n *\n * @param[in]  a        The source string you want to
    append.\n *\n * @param[in]  n        The number of characters you want to append
    from the\n *                      string.\n *\n * @return              The concatenated
    strings, NULL on error.\n *\n * @see talloc_strndup()\n * @see talloc_strndup_append_buffer()\n
    */\nchar *talloc_strndup_append(char *s, const char *a, size_t n);\n\n/**\n *
    @brief Append at most n characters of a string to given buffer\n *\n * This is
    a more efficient version of talloc_strndup_append(). It determines\n * the length
    of the destination string by the size of the talloc context.\n *\n * Use this
    very carefully as it produces a different result than\n * talloc_strndup_append()
    when a zero character is in the middle of the\n * destination string.\n *\n *
    @code\n *      char *str_a = talloc_strdup(NULL, \"hello world\");\n *      char
    *str_b = talloc_strdup(NULL, \"hello world\");\n *      str_a[5] = str_b[5] =
    '\\0'\n *\n *      char *app = talloc_strndup_append(str_a, \", hello\", 7);\n
    *      char *buf = talloc_strndup_append_buffer(str_b, \", hello\", 7);\n *\n
    *      printf(\"%s\\n\", app); // hello, hello (app = \"hello, hello\")\n *      printf(\"%s\\n\",
    buf); // hello (buf = \"hello\\0world, hello\")\n * @endcode\n *\n * If <code>s
    == NULL</code> then new context is created.\n *\n * @param[in]  s        The destination
    buffer to append to.\n *\n * @param[in]  a        The source string you want to
    append.\n *\n * @param[in]  n        The number of characters you want to append
    from the\n *                      string.\n *\n * @return              The concatenated
    strings, NULL on error.\n *\n * @see talloc_strndup()\n * @see talloc_strndup_append()\n
    * @see talloc_array_length()\n */\nchar *talloc_strndup_append_buffer(char *s,
    const char *a, size_t n);\n\n/**\n * @brief Format a string given a va_list.\n
    *\n * This function is the talloc equivalent of the C library function\n * vasprintf(3).\n
    *\n * This functions sets the name of the new pointer to the new string. This
    is\n * equivalent to:\n *\n * @code\n *      talloc_set_name_const(ptr, ptr)\n
    * @endcode\n *\n * @param[in]  t        The talloc context to hang the result
    off.\n *\n * @param[in]  fmt      The format string.\n *\n * @param[in]  ap       The
    parameters used to fill fmt.\n *\n * @return              The formatted string,
    NULL on error.\n */\nchar *talloc_vasprintf(const void *t, const char *fmt, va_list
    ap) PRINTF_ATTRIBUTE(2,0);\n\n/**\n * @brief Format a string given a va_list and
    append it to the given destination\n *        string.\n *\n * @param[in]  s        The
    destination string to append to.\n *\n * @param[in]  fmt      The format string.\n
    *\n * @param[in]  ap       The parameters used to fill fmt.\n *\n * @return              The
    formatted string, NULL on error.\n *\n * @see talloc_vasprintf()\n */\nchar *talloc_vasprintf_append(char
    *s, const char *fmt, va_list ap) PRINTF_ATTRIBUTE(2,0);\n\n/**\n * @brief Format
    a string given a va_list and append it to the given destination\n *        buffer.\n
    *\n * @param[in]  s        The destination buffer to append to.\n *\n * @param[in]
    \ fmt      The format string.\n *\n * @param[in]  ap       The parameters used
    to fill fmt.\n *\n * @return              The formatted string, NULL on error.\n
    *\n * @see talloc_vasprintf()\n */\nchar *talloc_vasprintf_append_buffer(char
    *s, const char *fmt, va_list ap) PRINTF_ATTRIBUTE(2,0);\n\n/**\n * @brief Format
    a string.\n *\n * This function is the talloc equivalent of the C library function
    asprintf(3).\n *\n * This functions sets the name of the new pointer to the new
    string. This is\n * equivalent to:\n *\n * @code\n *      talloc_set_name_const(ptr,
    ptr)\n * @endcode\n *\n * @param[in]  t        The talloc context to hang the
    result off.\n *\n * @param[in]  fmt      The format string.\n *\n * @param[in]
    \ ...      The parameters used to fill fmt.\n *\n * @return              The formatted
    string, NULL on error.\n */\nchar *talloc_asprintf(const void *t, const char *fmt,
    ...) PRINTF_ATTRIBUTE(2,3);\n\n/**\n * @brief Append a formatted string to another
    string.\n *\n * This function appends the given formatted string to the given
    string. Use\n * this variant when the string in the current talloc buffer may
    have been\n * truncated in length.\n *\n * This functions sets the name of the
    new pointer to the new\n * string. This is equivalent to:\n *\n * @code\n *      talloc_set_name_const(ptr,
    ptr)\n * @endcode\n *\n * If <code>s == NULL</code> then new context is created.\n
    *\n * @param[in]  s        The string to append to.\n *\n * @param[in]  fmt      The
    format string.\n *\n * @param[in]  ...      The parameters used to fill fmt.\n
    *\n * @return              The formatted string, NULL on error.\n */\nchar *talloc_asprintf_append(char
    *s, const char *fmt, ...) PRINTF_ATTRIBUTE(2,3);\n\n/**\n * @brief Append a formatted
    string to another string.\n *\n * This is a more efficient version of talloc_asprintf_append().
    It determines\n * the length of the destination string by the size of the talloc
    context.\n *\n * Use this very carefully as it produces a different result than\n
    * talloc_asprintf_append() when a zero character is in the middle of the\n * destination
    string.\n *\n * @code\n *      char *str_a = talloc_strdup(NULL, \"hello world\");\n
    *      char *str_b = talloc_strdup(NULL, \"hello world\");\n *      str_a[5] =
    str_b[5] = '\\0'\n *\n *      char *app = talloc_asprintf_append(str_a, \"%s\",
    \", hello\");\n *      char *buf = talloc_strdup_append_buffer(str_b, \"%s\",
    \", hello\");\n *\n *      printf(\"%s\\n\", app); // hello, hello (app = \"hello,
    hello\")\n *      printf(\"%s\\n\", buf); // hello (buf = \"hello\\0world, hello\")\n
    * @endcode\n *\n * If <code>s == NULL</code> then new context is created.\n *\n
    * @param[in]  s        The string to append to\n *\n * @param[in]  fmt      The
    format string.\n *\n * @param[in]  ...      The parameters used to fill fmt.\n
    *\n * @return              The formatted string, NULL on error.\n *\n * @see talloc_asprintf()\n
    * @see talloc_asprintf_append()\n */\nchar *talloc_asprintf_append_buffer(char
    *s, const char *fmt, ...) PRINTF_ATTRIBUTE(2,3);\n\n/* @} ******************************************************************/\n\n/**\n
    * @defgroup talloc_debug The talloc debugging support functions\n * @ingroup talloc\n
    *\n * To aid memory debugging, talloc contains routines to inspect the currently\n
    * allocated memory hierarchy.\n *\n * @{\n */\n\n/**\n * @brief Walk a complete
    talloc hierarchy.\n *\n * This provides a more flexible reports than talloc_report().
    It\n * will recursively call the callback for the entire tree of memory\n * referenced
    by the pointer. References in the tree are passed with\n * is_ref = 1 and the
    pointer that is referenced.\n *\n * You can pass NULL for the pointer, in which
    case a report is\n * printed for the top level memory context, but only if\n *
    talloc_enable_leak_report() or talloc_enable_leak_report_full()\n * has been called.\n
    *\n * The recursion is stopped when depth >= max_depth.\n * max_depth = -1 means
    only stop at leaf nodes.\n *\n * @param[in]  ptr      The talloc chunk.\n *\n
    * @param[in]  depth    Internal parameter to control recursion. Call with 0.\n
    *\n * @param[in]  max_depth  Maximum recursion level.\n *\n * @param[in]  callback
    \ Function to be called on every chunk.\n *\n * @param[in]  private_data  Private
    pointer passed to callback.\n */\nvoid talloc_report_depth_cb(const void *ptr,
    int depth, int max_depth,\n\t\t\t    void (*callback)(const void *ptr,\n\t\t\t\t\t
    \    int depth, int max_depth,\n\t\t\t\t\t     int is_ref,\n\t\t\t\t\t     void
    *private_data),\n\t\t\t    void *private_data);\n\n/**\n * @brief Print a talloc
    hierarchy.\n *\n * This provides a more flexible reports than talloc_report().
    It\n * will let you specify the depth and max_depth.\n *\n * @param[in]  ptr      The
    talloc chunk.\n *\n * @param[in]  depth    Internal parameter to control recursion.
    Call with 0.\n *\n * @param[in]  max_depth  Maximum recursion level.\n *\n * @param[in]
    \ f        The file handle to print to.\n */\nvoid talloc_report_depth_file(const
    void *ptr, int depth, int max_depth, FILE *f);\n\n/**\n * @brief Print a summary
    report of all memory used by ptr.\n *\n * This provides a more detailed report
    than talloc_report(). It will\n * recursively print the entire tree of memory
    referenced by the\n * pointer. References in the tree are shown by giving the
    name of the\n * pointer that is referenced.\n *\n * You can pass NULL for the
    pointer, in which case a report is printed\n * for the top level memory context,
    but only if\n * talloc_enable_leak_report() or talloc_enable_leak_report_full()
    has\n * been called.\n *\n * @param[in]  ptr      The talloc chunk.\n *\n * @param[in]
    \ f        The file handle to print to.\n *\n * Example:\n * @code\n *      unsigned
    int *a, *b;\n *      a = talloc(NULL, unsigned int);\n *      b = talloc(a, unsigned
    int);\n *      fprintf(stderr, \"Dumping memory tree for a:\\n\");\n *      talloc_report_full(a,
    stderr);\n * @endcode\n *\n * @see talloc_report()\n */\nvoid talloc_report_full(const
    void *ptr, FILE *f);\n\n/**\n * @brief Print a summary report of all memory used
    by ptr.\n *\n * This function prints a summary report of all memory used by ptr.
    One line of\n * report is printed for each immediate child of ptr, showing the
    total memory\n * and number of blocks used by that child.\n *\n * You can pass
    NULL for the pointer, in which case a report is printed\n * for the top level
    memory context, but only if talloc_enable_leak_report()\n * or talloc_enable_leak_report_full()
    has been called.\n *\n * @param[in]  ptr      The talloc chunk.\n *\n * @param[in]
    \ f        The file handle to print to.\n *\n * Example:\n * @code\n *      unsigned
    int *a, *b;\n *      a = talloc(NULL, unsigned int);\n *      b = talloc(a, unsigned
    int);\n *      fprintf(stderr, \"Summary of memory tree for a:\\n\");\n *      talloc_report(a,
    stderr);\n * @endcode\n *\n * @see talloc_report_full()\n */\nvoid talloc_report(const
    void *ptr, FILE *f);\n\n/**\n * @brief Enable tracking the use of NULL memory
    contexts.\n *\n * This enables tracking of the NULL memory context without enabling
    leak\n * reporting on exit. Useful for when you want to do your own leak\n * reporting
    call via talloc_report_null_full();\n */\nvoid talloc_enable_null_tracking(void);\n\n/**\n
    * @brief Enable tracking the use of NULL memory contexts.\n *\n * This enables
    tracking of the NULL memory context without enabling leak\n * reporting on exit.
    Useful for when you want to do your own leak\n * reporting call via talloc_report_null_full();\n
    */\nvoid talloc_enable_null_tracking_no_autofree(void);\n\n/**\n * @brief Disable
    tracking of the NULL memory context.\n *\n * This disables tracking of the NULL
    memory context.\n */\nvoid talloc_disable_null_tracking(void);\n\n/**\n * @brief
    Enable leak report when a program exits.\n *\n * This enables calling of talloc_report(NULL,
    stderr) when the program\n * exits. In Samba4 this is enabled by using the --leak-report
    command\n * line option.\n *\n * For it to be useful, this function must be called
    before any other\n * talloc function as it establishes a \"null context\" that
    acts as the\n * top of the tree. If you don't call this function first then passing\n
    * NULL to talloc_report() or talloc_report_full() won't give you the\n * full
    tree printout.\n *\n * Here is a typical talloc report:\n *\n * @code\n * talloc
    report on 'null_context' (total 267 bytes in 15 blocks)\n *      libcli/auth/spnego_parse.c:55
    \ contains     31 bytes in   2 blocks\n *      libcli/auth/spnego_parse.c:55  contains
    \    31 bytes in   2 blocks\n *      iconv(UTF8,CP850)              contains     42
    bytes in   2 blocks\n *      libcli/auth/spnego_parse.c:55  contains     31 bytes
    in   2 blocks\n *      iconv(CP850,UTF8)              contains     42 bytes in
    \  2 blocks\n *      iconv(UTF8,UTF-16LE)           contains     45 bytes in   2
    blocks\n *      iconv(UTF-16LE,UTF8)           contains     45 bytes in   2 blocks\n
    * @endcode\n */\nvoid talloc_enable_leak_report(void);\n\n/**\n * @brief Enable
    full leak report when a program exits.\n *\n * This enables calling of talloc_report_full(NULL,
    stderr) when the\n * program exits. In Samba4 this is enabled by using the\n *
    --leak-report-full command line option.\n *\n * For it to be useful, this function
    must be called before any other\n * talloc function as it establishes a \"null
    context\" that acts as the\n * top of the tree. If you don't call this function
    first then passing\n * NULL to talloc_report() or talloc_report_full() won't give
    you the\n * full tree printout.\n *\n * Here is a typical full report:\n *\n *
    @code\n * full talloc report on 'root' (total 18 bytes in 8 blocks)\n *      p1
    \                            contains     18 bytes in   7 blocks (ref 0)\n *      r1
    \                            contains     13 bytes in   2 blocks (ref 0)\n *      reference
    to: p2\n *      p2                             contains      1 bytes in   1 blocks
    (ref 1)\n *      x3                             contains      1 bytes in   1 blocks
    (ref 0)\n *      x2                             contains      1 bytes in   1 blocks
    (ref 0)\n *      x1                             contains      1 bytes in   1 blocks
    (ref 0)\n * @endcode\n */\nvoid talloc_enable_leak_report_full(void);\n\n/**\n
    * @brief Set a custom \"abort\" function that is called on serious error.\n *\n
    * The default \"abort\" function is <code>abort()</code>.\n *\n * The \"abort\"
    function is called when:\n *\n * <ul>\n *  <li>talloc_get_type_abort() fails</li>\n
    *  <li>the provided pointer is not a valid talloc context</li>\n *  <li>when the
    context meta data are invalid</li>\n *  <li>when access after free is detected</li>\n
    * </ul>\n *\n * Example:\n *\n * @code\n * void my_abort(const char *reason)\n
    * {\n *      fprintf(stderr, \"talloc abort: %s\\n\", reason);\n *      abort();\n
    * }\n *\n *      talloc_set_abort_fn(my_abort);\n * @endcode\n *\n * @param[in]
    \ abort_fn      The new \"abort\" function.\n *\n * @see talloc_set_log_fn()\n
    * @see talloc_get_type()\n */\nvoid talloc_set_abort_fn(void (*abort_fn)(const
    char *reason));\n\n/**\n * @brief Set a logging function.\n *\n * @param[in]  log_fn
    \     The logging function.\n *\n * @see talloc_set_log_stderr()\n * @see talloc_set_abort_fn()\n
    */\nvoid talloc_set_log_fn(void (*log_fn)(const char *message));\n\n/**\n * @brief
    Set stderr as the output for logs.\n *\n * @see talloc_set_log_fn()\n * @see talloc_set_abort_fn()\n
    */\nvoid talloc_set_log_stderr(void);\n\n/**\n * @brief Set a max memory limit
    for the current context hierarchy\n *\t  This affects all children of this context
    and constrain any\n *\t  allocation in the hierarchy to never exceed the limit
    set.\n *\t  The limit can be removed by setting 0 (unlimited) as the\n *\t  max_size
    by calling the funciton again on the sam context.\n *\t  Memory limits can also
    be nested, meaning a hild can have\n *\t  a stricter memory limit than a parent.\n
    *\t  Memory limits are enforced only at memory allocation time.\n *\t  Stealing
    a context into a 'limited' hierarchy properly\n *\t  updates memory usage but
    does *not* cause failure if the\n *\t  move causes the new parent to exceed its
    limits. However\n *\t  any further allocation on that hierarchy will then fail.\n
    *\n * @param[in]\tctx\t\tThe talloc context to set the limit on\n * @param[in]\tmax_size\tThe
    (new) max_size\n */\nint talloc_set_memlimit(const void *ctx, size_t max_size);\n\n/*
    @} ******************************************************************/\n\n#if
    TALLOC_DEPRECATED\n#define talloc_zero_p(ctx, type) talloc_zero(ctx, type)\n#define
    talloc_p(ctx, type) talloc(ctx, type)\n#define talloc_array_p(ctx, type, count)
    talloc_array(ctx, type, count)\n#define talloc_realloc_p(ctx, p, type, count)
    talloc_realloc(ctx, p, type, count)\n#define talloc_destroy(ctx) talloc_free(ctx)\n#define
    talloc_append_string(c, s, a) (s?talloc_strdup_append(s,a):talloc_strdup(c, a))\n#endif\n\n#ifndef
    TALLOC_MAX_DEPTH\n#define TALLOC_MAX_DEPTH 10000\n#endif\n\n#ifdef __cplusplus\n}
    /* end of extern \"C\" */\n#endif\n\n#endif\n"
